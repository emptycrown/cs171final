(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Points = {})));
}(this, (function (exports) { 'use strict';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};





















var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

// I extracted this from the a2c function from
// SVG path – https://github.com/fontello/svgpath
//
// All credit goes to:
//
// Sergey Batishchev – https://github.com/snb2013
// Vitaly Puzrin – https://github.com/puzrin
// Alex Kocharin – https://github.com/rlidwka

var TAU = Math.PI * 2;

var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x,
      y = _ref.y;

  x *= rx;
  y *= ry;

  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;

  return {
    x: xp + centerx,
    y: yp + centery
  };
};

var approxUnitArc = function approxUnitArc(ang1, ang2) {
  var a = 4 / 3 * Math.tan(ang2 / 4);

  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);

  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};

var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var umag = Math.sqrt(ux * ux + uy * uy);
  var vmag = Math.sqrt(ux * ux + uy * uy);
  var dot = ux * vx + uy * vy;

  var div = dot / (umag * vmag);

  if (div > 1) {
    div = 1;
  }

  if (div < -1) {
    div = -1;
  }

  return sign * Math.acos(div);
};

var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);

  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

  if (radicant < 0) {
    radicant = 0;
  }

  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;

  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;

  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }

  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }

  return [centerx, centery, ang1, ang2];
};

var arcToBezier = function arcToBezier(_ref2) {
  var px = _ref2.px,
      py = _ref2.py,
      cx = _ref2.cx,
      cy = _ref2.cy,
      rx = _ref2.rx,
      ry = _ref2.ry,
      _ref2$xAxisRotation = _ref2.xAxisRotation,
      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
      _ref2$largeArcFlag = _ref2.largeArcFlag,
      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
      _ref2$sweepFlag = _ref2.sweepFlag,
      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

  var curves = [];

  if (rx === 0 || ry === 0) {
    return [];
  }

  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);

  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

  if (pxp === 0 && pyp === 0) {
    return [];
  }

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
      _getArcCenter2 = slicedToArray(_getArcCenter, 4),
      centerx = _getArcCenter2[0],
      centery = _getArcCenter2[1],
      ang1 = _getArcCenter2[2],
      ang2 = _getArcCenter2[3];

  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);

  ang2 /= segments;

  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }

  return curves.map(function (curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
        x1 = _mapToEllipse.x,
        y1 = _mapToEllipse.y;

    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
        x2 = _mapToEllipse2.x,
        y2 = _mapToEllipse2.y;

    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
        x = _mapToEllipse3.x,
        y = _mapToEllipse3.y;

    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
  });
};

var angleFromSides = function angleFromSides(a, b, c) {
  var r = Math.acos((Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b));

  return r * (180 / Math.PI);
};

var applyFuncToShapes = function applyFuncToShapes(f, s) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (isShapeArray(s)) {
    return s.map(function (shape) {
      return f.apply(undefined, [shape].concat(args));
    });
  }

  return f.apply(undefined, [s].concat(args));
};

var getShapeArray = function getShapeArray(s) {
  return isShapeArray(s) ? s : [s];
};

var isShapeArray = function isShapeArray(s) {
  return Array.isArray(s[0]);
};

var numberAtInterval = function numberAtInterval(a, b, interval) {
  var c = a === b ? 0 : Math.abs(b - a);
  return c === 0 ? a : a < b ? a + c * interval : a - c * interval;
};

var cubifyShape = function cubifyShape(shape) {
  var s = [];

  for (var i = 0, l = shape.length; i < l; i++) {
    var point = shape[i];

    if (point.curve && point.curve.type !== 'cubic') {
      var _shape = shape[i - 1],
          px = _shape.x,
          py = _shape.y;
      var cx = point.x,
          cy = point.y;


      if (point.curve.type === 'arc') {
        var curves = arcToBezier({
          px: px,
          py: py,
          cx: cx,
          cy: cy,
          rx: point.curve.rx,
          ry: point.curve.ry,
          xAxisRotation: point.curve.xAxisRotation,
          largeArcFlag: point.curve.largeArcFlag,
          sweepFlag: point.curve.sweepFlag
        });

        curves.forEach(function (_ref) {
          var x1 = _ref.x1,
              y1 = _ref.y1,
              x2 = _ref.x2,
              y2 = _ref.y2,
              x = _ref.x,
              y = _ref.y;

          s.push({ x: x, y: y, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
        });
      } else if (point.curve.type === 'quadratic') {
        var x1 = px + 2 / 3 * (point.curve.x1 - px);
        var y1 = py + 2 / 3 * (point.curve.y1 - py);
        var x2 = cx + 2 / 3 * (point.curve.x1 - cx);
        var y2 = cy + 2 / 3 * (point.curve.y1 - cy);

        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 } });
      }
    } else {
      s.push(point);
    }
  }

  return s;
};

var cubify = function cubify(s) {
  return applyFuncToShapes(cubifyShape, s);
};

var linearPoints = function linearPoints(from, to) {
  return [{
    x: numberAtInterval(from.x, to.x, 0.5),
    y: numberAtInterval(from.y, to.y, 0.5)
  }, to];
};

var curvedPoints = function curvedPoints(from, to) {
  var _to$curve = to.curve,
      x1 = _to$curve.x1,
      y1 = _to$curve.y1,
      x2 = _to$curve.x2,
      y2 = _to$curve.y2;


  var A = { x: from.x, y: from.y };
  var B = { x: x1, y: y1 };
  var C = { x: x2, y: y2 };
  var D = { x: to.x, y: to.y };
  var E = { x: numberAtInterval(A.x, B.x, 0.5), y: numberAtInterval(A.y, B.y, 0.5) };
  var F = { x: numberAtInterval(B.x, C.x, 0.5), y: numberAtInterval(B.y, C.y, 0.5) };
  var G = { x: numberAtInterval(C.x, D.x, 0.5), y: numberAtInterval(C.y, D.y, 0.5) };
  var H = { x: numberAtInterval(E.x, F.x, 0.5), y: numberAtInterval(E.y, F.y, 0.5) };
  var J = { x: numberAtInterval(F.x, G.x, 0.5), y: numberAtInterval(F.y, G.y, 0.5) };
  var K = { x: numberAtInterval(H.x, J.x, 0.5), y: numberAtInterval(H.y, J.y, 0.5) };

  return [{ x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } }, { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }];
};

var points = function points(from, to) {
  return to.curve ? curvedPoints(from, to) : linearPoints(from, to);
};

var addPoints = function addPoints(shape, pointsRequired) {
  if (isNaN(pointsRequired)) {
    throw Error('`add` function must be passed a number as the second argument');
  }

  var nextShape = [].concat(toConsumableArray(shape));

  for (var i = 1; i < nextShape.length;) {
    if (nextShape.length >= pointsRequired) {
      return nextShape;
    }

    var to = nextShape[i];

    if (to.moveTo) {
      i++;
    } else {
      var from = nextShape[i - 1];

      var _points = points(from, to),
          _points2 = slicedToArray(_points, 2),
          midPoint = _points2[0],
          replacementPoint = _points2[1];

      nextShape.splice(i, 1, midPoint, replacementPoint);

      i += 2;
    }
  }

  return addPoints(nextShape, pointsRequired);
};

var add = function add(shape, pointsRequired) {
  return addPoints(cubify(shape), pointsRequired);
};

var length = function length(shape, accuracy) {
  var s = decurve(shape, accuracy);

  return s.reduce(function (currentLength, _ref, i) {
    var x2 = _ref.x,
        y2 = _ref.y,
        moveTo = _ref.moveTo;

    if (!moveTo) {
      var _s = s[i - 1],
          x1 = _s.x,
          y1 = _s.y;

      currentLength += linearLength(x1, y1, x2, y2);
    }

    return currentLength;
  }, 0);
};

var linearLength = function linearLength(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};

var angle = function angle(triangle) {
  var _triangle$ = slicedToArray(triangle[0], 2),
      ax = _triangle$[0],
      ay = _triangle$[1];

  var _triangle$2 = slicedToArray(triangle[1], 2),
      bx = _triangle$2[0],
      by = _triangle$2[1];

  var _triangle$3 = slicedToArray(triangle[2], 2),
      cx = _triangle$3[0],
      cy = _triangle$3[1];

  var a = linearLength(ax, ay, bx, by);
  var b = linearLength(bx, by, cx, cy);
  var c = linearLength(cx, cy, ax, ay);

  return angleFromSides(a, b, c);
};

var curved = function curved(shape) {
  return shape.reduce(function (c, _ref) {
    var curve = _ref.curve;
    return curve ? true : c;
  }, false);
};

var decurve = function decurve(shape) {
  var accuracy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

  if (!curved(shape)) {
    return shape;
  }

  var s = cubify(shape);
  var d = [];

  s.map(function (point, i) {
    if (point.curve) {
      var prevPoint = s[i - 1];
      straighten(prevPoint, point, accuracy).map(function (p) {
        return d.push(p);
      });
    } else {
      d.push(point);
    }
  });

  return d;
};

var straight = function straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) {
  var t1 = [[cx1, cy1], [x2, y2], [x1, y1]];
  var t2 = [[cx2, cy2], [x1, y1], [x2, y2]];
  return angle(t1) < accuracy && angle(t2) < accuracy;
};

var straighten = function straighten(prevPoint, point, accuracy) {
  var x1 = prevPoint.x,
      y1 = prevPoint.y;
  var x2 = point.x,
      y2 = point.y,
      curve = point.curve;
  var cx1 = curve.x1,
      cy1 = curve.y1,
      cx2 = curve.x2,
      cy2 = curve.y2;


  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {
    return [point];
  }

  var _curvedPoints = curvedPoints(prevPoint, point),
      _curvedPoints2 = slicedToArray(_curvedPoints, 2),
      midPoint = _curvedPoints2[0],
      lastPoint = _curvedPoints2[1];

  return [].concat(toConsumableArray(straighten(prevPoint, midPoint, accuracy)), toConsumableArray(straighten(midPoint, lastPoint, accuracy)));
};

var boundingBox = function boundingBox(s) {
  var bottom = void 0;
  var left = void 0;
  var right = void 0;
  var top = void 0;

  var shapes = getShapeArray(s);

  shapes.map(function (shape) {
    return decurve(shape).map(function (_ref) {
      var x = _ref.x,
          y = _ref.y;

      if (typeof bottom !== 'number' || y > bottom) {
        bottom = y;
      }

      if (typeof left !== 'number' || x < left) {
        left = x;
      }

      if (typeof right !== 'number' || x > right) {
        right = x;
      }

      if (typeof top !== 'number' || y < top) {
        top = y;
      }
    });
  });

  return {
    bottom: bottom,
    center: {
      x: left + (right - left) / 2,
      y: top + (bottom - top) / 2
    },
    left: left,
    right: right,
    top: top
  };
};

var countLinePoints = function countLinePoints(lines) {
  return lines.reduce(function (count, points) {
    return count + countPoints(points);
  }, 0);
};

var countPoints = function countPoints(points) {
  return points.length - (isJoined(points) ? 1 : 0);
};

var isJoined = function isJoined(points) {
  var firstPoint = points[0];
  var lastPoint = points[points.length - 1];
  return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
};

var joinLines = function joinLines(lines) {
  return lines.reduce(function (shape, line) {
    return [].concat(toConsumableArray(shape), toConsumableArray(line));
  }, []);
};

var moveIndex = function moveIndex(shape, offset) {
  var lines = splitLines(shape);
  var count = countLinePoints(lines);
  var normalisedOffset = (offset % count + count) % count;

  if (!normalisedOffset) {
    return shape;
  }

  var _nextIndex = nextIndex(lines, normalisedOffset),
      lineIndex = _nextIndex.lineIndex,
      pointIndex = _nextIndex.pointIndex;

  var reorderedLines = reorderLines(lines, lineIndex);
  var firstLine = reorderPoints(reorderedLines[0], pointIndex);
  var restOfLines = [].concat(toConsumableArray(reorderedLines)).splice(1);

  return joinLines([firstLine].concat(toConsumableArray(restOfLines)));
};

var nextIndex = function nextIndex(lines, offset) {
  for (var i = 0, l = lines.length; i < l; i++) {
    var count = countPoints(lines[i]);

    if (offset <= count - 1) {
      return {
        lineIndex: i,
        pointIndex: offset
      };
    }

    offset -= count;
  }
};

var reorderLines = function reorderLines(lines, offset) {
  return [].concat(toConsumableArray(lines)).splice(offset).concat([].concat(toConsumableArray(lines)).splice(0, offset));
};

var reorderPoints = function reorderPoints(points, offset) {
  if (!offset) {
    return points;
  }

  var nextPoints = [{ x: points[offset].x, y: points[offset].y, moveTo: true }].concat(toConsumableArray([].concat(toConsumableArray(points)).splice(offset + 1)));

  if (isJoined(points)) {
    return [].concat(toConsumableArray(nextPoints), toConsumableArray([].concat(toConsumableArray(points)).splice(1, offset)));
  }

  return [].concat(toConsumableArray(nextPoints), toConsumableArray([].concat(toConsumableArray(points)).splice(0, offset + 1)));
};

var splitLines = function splitLines(shape) {
  return shape.reduce(function (lines, point) {
    if (point.moveTo) {
      lines.push([]);
    }

    lines[lines.length - 1].push(point);

    return lines;
  }, []);
};

var offsetPoints = function offsetPoints(shape, x, y) {
  return shape.map(function (point) {
    var p = _extends({}, point);

    p.x += x;
    p.y += y;

    if (p.curve) {
      p.curve = _extends({}, p.curve);

      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
        p.curve.x1 += x;
        p.curve.y1 += y;
      }

      if (p.curve.type === 'cubic') {
        p.curve.x2 += x;
        p.curve.y2 += y;
      }
    }

    return p;
  });
};

var offset = function offset(s) {
  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return applyFuncToShapes(offsetPoints, s, x, y);
};

var angle$1 = function angle(x1, y1, x2, y2, a) {
  if (x1 === x2) {
    return y1 >= y2 ? 0 : 180;
  }

  var b = 100;
  var c = linearLength(x2, y2, x1, y1 - b);
  var ang = angleFromSides(a, b, c);

  return x1 < x2 ? ang : 360 - ang;
};

var over = function over(shape, length$$1, totalLength, desiredLength) {
  var _shape = shape[length$$1 - 2],
      x1 = _shape.x,
      y1 = _shape.y;
  var _shape2 = shape[length$$1 - 1],
      x2 = _shape2.x,
      y2 = _shape2.y;

  var segmentLength = linearLength(x1, y1, x2, y2);
  var segmentInterval = (desiredLength - totalLength) / segmentLength + 1;
  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
};

var position = function position(shape, interval, accuracy) {
  var s = decurve(shape, accuracy);
  var l = s.length;
  var t = length(s);
  var d = t * interval;

  var _ref = interval > 1 ? over(s, l, t, d) : interval < 0 ? under(s, d) : within(s, l, d),
      x1 = _ref.x1,
      y1 = _ref.y1,
      x2 = _ref.x2,
      y2 = _ref.y2,
      segmentInterval = _ref.segmentInterval,
      segmentLength = _ref.segmentLength;

  return {
    angle: angle$1(x1, y1, x2, y2, segmentLength),
    x: numberAtInterval(x1, x2, segmentInterval),
    y: numberAtInterval(y1, y2, segmentInterval)
  };
};

var under = function under(shape, desiredLength) {
  var _shape$ = shape[0],
      x1 = _shape$.x,
      y1 = _shape$.y;
  var _shape$2 = shape[1],
      x2 = _shape$2.x,
      y2 = _shape$2.y;

  var segmentLength = linearLength(x1, y1, x2, y2);
  var segmentInterval = desiredLength / segmentLength;
  return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
};

var within = function within(shape, length$$1, desiredLength) {
  var currentLength = 0;

  for (var i = 0; i < length$$1; i++) {
    var moveTo = shape[i].moveTo;


    if (!moveTo) {
      var _shape3 = shape[i - 1],
          x1 = _shape3.x,
          y1 = _shape3.y;
      var _shape$i = shape[i],
          x2 = _shape$i.x,
          y2 = _shape$i.y;


      var segmentLength = linearLength(x1, y1, x2, y2);

      if (currentLength + segmentLength >= desiredLength) {
        var segmentInterval = (desiredLength - currentLength) / segmentLength;
        return { x1: x1, y1: y1, x2: x2, y2: y2, segmentInterval: segmentInterval, segmentLength: segmentLength };
      }

      currentLength += segmentLength;
    }
  }
};

var isBetween = function isBetween(a, b, c) {
  if (b.curve || c.curve) {
    return false;
  }

  var crossProduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y);

  if (Math.abs(crossProduct) > Number.EPSILON) {
    return false;
  }

  var dotProduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y) * (b.y - a.y);

  if (dotProduct < 0) {
    return false;
  }

  var squaredLengthBA = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);

  if (dotProduct > squaredLengthBA) {
    return false;
  }

  return true;
};

var removePoints = function removePoints(shape) {
  var s = [];

  for (var i = 0, l = shape.length; i < l; i++) {
    var a = s[s.length - 1];
    var b = shape[i + 1];
    var c = shape[i];

    if (!(a && b && c) || !isBetween(a, b, c)) {
      s.push(c);
    }
  }

  return s;
};

var remove = function remove(s) {
  return applyFuncToShapes(removePoints, s);
};

var reversePoints = function reversePoints(shape) {
  var m = void 0;
  var c = void 0;

  return shape.reverse().map(function (_ref, i) {
    var x = _ref.x,
        y = _ref.y,
        moveTo = _ref.moveTo,
        curve = _ref.curve;

    var point = { x: x, y: y };

    if (c) {
      var _c = c,
          x2 = _c.x1,
          y2 = _c.y1,
          x1 = _c.x2,
          y1 = _c.y2;

      point.curve = { type: 'cubic', x1: x1, y1: y1, x2: x2, y2: y2 };
    }

    if (i === 0 || m) {
      point.moveTo = true;
    }

    m = moveTo;
    c = curve || null;

    return point;
  });
};

var reverse = function reverse(s) {
  return applyFuncToShapes(reversePoints, cubify(s));
};

var rotatePoint = function rotatePoint(x, y, c, s, about) {
  var offsetX = about.x,
      offsetY = about.y;

  var relativeX = x - offsetX;
  var relativeY = y - offsetY;

  return [relativeX * c - relativeY * s + offsetX, relativeX * s + relativeY * c + offsetY];
};

var rotatePoints = function rotatePoints(shape, angle, about) {
  return shape.map(function (point) {
    var r = angle * Math.PI / 180;
    var c = Math.cos(r);
    var s = Math.sin(r);

    var _rotatePoint = rotatePoint(point.x, point.y, c, s, about),
        _rotatePoint2 = slicedToArray(_rotatePoint, 2),
        x = _rotatePoint2[0],
        y = _rotatePoint2[1];

    var p = _extends({}, point, { x: x, y: y });

    if (p.curve) {
      if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {
        var _rotatePoint3 = rotatePoint(p.curve.x1, p.curve.y1, c, s, about),
            _rotatePoint4 = slicedToArray(_rotatePoint3, 2),
            x1 = _rotatePoint4[0],
            y1 = _rotatePoint4[1];

        p.curve = _extends({}, p.curve, { x1: x1, y1: y1 });
      }

      if (p.curve.type === 'cubic') {
        var _rotatePoint5 = rotatePoint(p.curve.x2, p.curve.y2, c, s, about),
            _rotatePoint6 = slicedToArray(_rotatePoint5, 2),
            x2 = _rotatePoint6[0],
            y2 = _rotatePoint6[1];

        p.curve = _extends({}, p.curve, { x2: x2, y2: y2 });
      }
    }

    return p;
  });
};

var rotate = function rotate(s, angle) {
  var _boundingBox = boundingBox(s),
      about = _boundingBox.center;

  return applyFuncToShapes(rotatePoints, s, angle, about);
};

var scalePoint = function scalePoint(point, scaleFactor, anchorX, anchorY) {
  var p = _extends({}, point);

  p.x = anchorX - (anchorX - p.x) * scaleFactor;
  p.y = anchorY - (anchorY - p.y) * scaleFactor;

  if (point.curve) {
    p.curve = _extends({}, p.curve);

    if (p.curve.type === 'arc') {
      if (p.curve.rx) {
        p.curve.rx = p.curve.rx * scaleFactor;
      }

      if (p.curve.ry) {
        p.curve.ry = p.curve.ry * scaleFactor;
      }
    } else {
      p.curve.x1 = anchorX - (anchorX - p.curve.x1) * scaleFactor;
      p.curve.y1 = anchorY - (anchorY - p.curve.y1) * scaleFactor;

      if (p.curve.type === 'cubic') {
        p.curve.x2 = anchorX - (anchorX - p.curve.x2) * scaleFactor;
        p.curve.y2 = anchorY - (anchorY - p.curve.y2) * scaleFactor;
      }
    }
  }

  return p;
};

var scale = function scale(s, scaleFactor) {
  var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'center';

  var _boundingBox = boundingBox(s),
      bottom = _boundingBox.bottom,
      center = _boundingBox.center,
      left = _boundingBox.left,
      right = _boundingBox.right,
      top = _boundingBox.top;

  var anchorX = center.x;
  var anchorY = center.y;

  switch (anchor) {
    case 'topLeft':
      anchorX = left;
      anchorY = top;
      break;
    case 'topRight':
      anchorX = right;
      anchorY = top;
      break;
    case 'bottomRight':
      anchorX = right;
      anchorY = bottom;
      break;
    case 'bottomLeft':
      anchorX = left;
      anchorY = bottom;
      break;
  }

  return applyFuncToShapes(function (shape) {
    return shape.map(function (point) {
      return scalePoint(point, scaleFactor, anchorX, anchorY);
    });
  }, s);
};

exports.add = add;
exports.boundingBox = boundingBox;
exports.cubify = cubify;
exports.length = length;
exports.moveIndex = moveIndex;
exports.offset = offset;
exports.position = position;
exports.remove = remove;
exports.reverse = reverse;
exports.rotate = rotate;
exports.scale = scale;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=points.js.map
